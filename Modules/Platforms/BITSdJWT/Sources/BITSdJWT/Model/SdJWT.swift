import BITCore
import Foundation

// MARK: - SdJWTError

public enum SdJWTError: Error {
  case notFound
  case invalidRawCredentialJWT
  case invalidCredentialSubject
  case invalidVC
}

// MARK: - SdJWT

public struct SdJWT: Codable, Equatable {

  // MARK: Lifecycle

  public init?(from rawCredential: String, sdJWTDecoder: SdJWTDecoder = SdJWTDecoder()) {
    guard let firstSdJwtPart = rawCredential.separatedByDisclosures.first else { return nil }
    do {
      let digestsValue = try sdJWTDecoder.decodeDigests(from: rawCredential)
      let claimsValue = try sdJWTDecoder.decodeClaims(from: rawCredential, digests: digestsValue)

      jwt = try JWT(raw: String(firstSdJwtPart))
      raw = rawCredential
      digests = digestsValue
      claims = claimsValue
      verifiableCredential = sdJWTDecoder.decodeVerifiableCredential(from: jwt)
      jwtIssuedAt = sdJWTDecoder.decodeTimestamp(from: jwt, with: "iat")
      jwtExpiredAt = sdJWTDecoder.decodeTimestamp(from: jwt, with: "exp")
      jwtActivatedAt = sdJWTDecoder.decodeTimestamp(from: jwt, with: "nbf")

      validUntil = verifiableCredential?.validUntil
      validFrom = verifiableCredential?.validFrom
    } catch {
      return nil
    }
  }

  public init?(from jwt: JWT, rawDisclosures: String, sdJWTDecoder: SdJWTDecoder = SdJWTDecoder()) {
    let combinedJwtAndDisclosures = [jwt.raw, rawDisclosures].joined(separator: String(SdJWT.disclosuresSeparator))
    let rawCredential = combinedJwtAndDisclosures.appending(String(SdJWT.disclosuresSeparator))
    self.init(from: rawCredential, sdJWTDecoder: sdJWTDecoder)
  }

  public init?(from rawCredentialData: Data) {
    guard let rawCredential = String(data: rawCredentialData, encoding: .utf8) else { return nil }
    self.init(from: rawCredential)
  }

  public init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    let rawCredential = try container.decode(String.self, forKey: .raw)
    guard let sdJwt = SdJWT(from: rawCredential) else {
      let context = DecodingError.Context(
        codingPath: decoder.codingPath,
        debugDescription: "Failed to convert Data to SdJWT")
      throw DecodingError.dataCorrupted(context)
    }
    self = sdJwt
  }

  // MARK: Public

  public static let format: String = "jwt_vc"
  public static let disclosuresSeparator: Character = "~"

  /// The raw value of the SdJwt. e.g. "jwtHeader.jwtBody.jwtSignature~disclosure1~disclosure2"
  public let raw: String

  /// The first element of the ´raw´, without the disclosures. e.g. "jwtHeader.jwtBody.jwtSignature"
  public let jwt: JWT

  /// The decoded claims of the disclosures of the SD-JWT
  public let claims: [SdJWTClaim]

  /// The list of digests contained in the VC generated by the issuer for each claims
  public let digests: [SdJwtDigest]

  /// The VC containing the status and the expiration, activation dates
  public let verifiableCredential: SdJWTVc?

  /// JWT `iat`
  public var jwtIssuedAt: Date?

  /// JWT `exp`
  public var jwtExpiredAt: Date?

  /// JWT `nbf`
  public var jwtActivatedAt: Date?

  /// Credential `validFrom`
  public var validFrom: Date?

  /// Credential `validUntil`
  public var validUntil: Date?

  // MARK: Internal

  enum CodingKeys: String, CodingKey {
    case raw = "credential"
    case claims
    case digests
  }

}

extension SdJWT {

  public var revocationStatus: SdJWTCredentialStatus? {
    verifiableCredential?.credentialStatus.first(where: { $0.statusPurpose == .revocation })
  }

  public var suspensionStatus: SdJWTCredentialStatus? {
    verifiableCredential?.credentialStatus.first(where: { $0.statusPurpose == .suspension })
  }

  /// Parse and resolve the selective disclosures of an SdJWT's claims
  ///
  /// - Parse the 'credentialSubject' of a 'vc'
  /// - Find the selectiveDisclosures in the claims of the SdJWT
  /// - Add them to the credentialSubject dictionary
  ///
  /// - Returns:A dictionary representing the payload of a credential with the selective disclosures in the 'vc.credentialSubject'
  public func resolveSelectiveDisclosures() throws -> [String: Any] {
    let credentialSubjectKey = "credentialSubject"
    let vcKey = "vc"
    guard
      let jwtPayload = JWTDecoder().decodePayload(from: jwt.raw),
      var payloadDictionary = try JSONSerialization.jsonObject(with: jwtPayload) as? [String: Any],
      var vc = payloadDictionary[vcKey] as? [String: Any],
      var credentialSubjects = vc[credentialSubjectKey] as? [String: Any] else
    {
      throw SdJWTError.invalidCredentialSubject
    }

    for claim in claims {
      do { credentialSubjects[claim.key] = try claim.anyValue() }
      catch { /* ignore this claim */ }
    }

    vc[credentialSubjectKey] = credentialSubjects
    payloadDictionary[vcKey] = vc
    return payloadDictionary
  }
}
